### 手写promise
想要进行手写Promise，首先需要知道**promise 的基本特性及用法**

- promise 有三种状态，pending等待、fulfilled 完成、rejected 失败

- pending 可以转为 fulfilled，也可转为 rejected，一旦状态转变了，状态不可再更改

- resolve 为成功，状态由 pending 转为 fulfilled，并且接收参数 value

- reject 为失败，状态由 pending 转为 rejected，并且接收参数 reason

- then 方法接收两个参数分别为 onFulfilled 和 onRejected，当 pending => fulfilled 后执行 onFulFilled，当 pending => rejected 后执行 onRejected

- 支持链式调用，可以在创建promise后通过.then一直触发

- 静态方法的实现，比如Promise.resolve()和Promise.reject()，Promise.all()方法

**实现一个最基本的 promise案例**，**这个是我们代码完成后要实现的效果**

```js
let p = new Promise((resolve, reject) => {
  resolve('success')
  // reject('error')
})
p.then(data => {
  console.log(data)
})
```

#### 1.1 需要创建一个类，并且添加一个回调方法 executor，作为Promise 的参数
```js
class MPromise {
 constructor(executor) {
    // 回调函数
    executor()
  }
}
```
#### 1.2 executor接收resolve 和 reject 作为参数
```js
class MPromise {
 constructor(executor) {
     //成功的参数
    this.value = undefined
     //失败的参数
    this.reason = undefined
     
    const resolve = (value) => {
      this.value = value
    }
    const reject = (reason) => {
      this.reason = reason
    }
    executor(resolve, reject)
  }
}
```
#### 1.3 定义promise的三种状态，实现then方法
```js
class MPromise {
 constructor(executor) {
    //成功的参数
    this.value = undefined
    //失败的参数
    this.reason = undefined
    // 定义promise的状态
    this.state = 'pending'
    
    const resolve = (value) => {
      if (this.state === 'pending') {
        // 状态修改为成功
        this.state = 'fulfilled'
        this.value = value
      }
      
    }
    const reject = (reason) => {
      // 状态修改为失败
      if (this.state === 'pending') {
        this.state = 'rejected'
        this.reason = reason
      }
    }
    executor(resolve, reject)
  }
  // 实现 then 方法
  then(onFulfilled, onRejected) {
    if (this.state === 'fulfilled') {
      // 接收成功传来的数据
      onFulfilled(this.value)
    }
    if (this.state === 'rejected') {
      // 接收失败传来的数据
      onRejected(this.reason)
    }
  }
}
```

执行案列
```js
const p = new MPromise((resolve, reject) => {
  resolve('success')
})
console.log(p)
p.then((val) => {
  console.log(val, 'val')
})
```
很显然 上面的案例是一个同步操作，我们来看下第二个案例
```js
const p = new MPromise((resolve, reject) => {
  // 添加定时器
  setTimeout(() => {
      resolve('success')
  }, 1000)
})
console.log(p, 'p')
p.then((val) => {
  // 无法触发
  console.log(val, 'val')
})
```
#### 原因：
因为到目前为止，实现的 promise 都是同步的，当我们执行 executor 时先把同步操作执行完成，发现有一个异步操作 settimeout，先让他去排队了(这里需要了解一下事件循环机制)，然后立刻去同步执行了 then 方法。
#### 解决思路：
既然 then 自己无法知道 resolve 什么时候执行，是否执行了，那resolve执行完后就需要有个东西告诉then，执行完了。

```js
class MPromise {
 constructor(executor) {
    //成功的参数
    this.value = undefined
    //失败的参数
    this.reason = undefined
    // 定义promise的状态
    this.state = 'pending'
    // 定义数组，存放稍后要完成的任务
    this.onResolvedCallbacks = []
    this.onRejectedCallbacks = []

    const resolve = (value) => {
      if (this.state === 'pending') {
        // 状态修改为成功
        this.state = 'fulfilled'
        this.value = value
        /* 成功了，在这个例子中，相当于过了 1秒了开始执行resolve了，
        状态改变后，把我们预约好的任务拿出来依次执行 */
        this.onResolvedCallbacks.forEach(fn => fn())
      }
      
    }
    const reject = (reason) => {
      // 状态修改为失败
      if (this.state === 'pending') {
        this.state = 'rejected'
        this.reason = reason
        this.onRejectedCallbacks.forEach(fn => fn())
      }
    }
    executor(resolve, reject)
  }
  // 实现 then 方法
  then(onFulfilled, onRejected) {
    if (this.state === 'fulfilled') {
      // 接收成功传来的数据
      onFulfilled(this.value)
    }
    if (this.state === 'rejected') {
      // 接收失败传来的数据
      onRejected(this.reason)
    }
    if(this.state === 'pending') {
      /* 因为异步导致 state 还在 pending 状态 
      所以把 要做的任务先放到预约的数组队列里
      */
      this.onResolvedCallbacks.push(() => {
        onFulfilled(this.value)
      })
      this.onRejectedCallbacks.push(() => {
        onRejected(this.reason)
      })
    }
  }
}
```

#### 2.1 链式调用
链式调用的本质是需要调用then方法后返回一个promise对象
```js
let p = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve('延迟1秒')
  }, 1000)
})
p.then(data => {
  let str = data + '我再第一个 then 里！'
  console.log(str)
  return str
}).then(data => {
  let str = data + '我在第二个 then 里！'
  console.log(str)
})
```
代码实现
```js
class MPromise {
 constructor(executor) {
    //成功的参数
    this.value = undefined
    //失败的参数
    this.reason = undefined
    // 定义promise的状态
    this.state = 'pending'
    // 定义数组，存放稍后要完成的任务
    this.onResolvedCallbacks = []
    this.onRejectedCallbacks = []

    const resolve = (value) => {
      if (this.state === 'pending') {
        // 状态修改为成功
        this.state = 'fulfilled'
        this.value = value
        /* 成功了，在这个例子中，相当于过了 1秒了开始执行resolve了，
        状态改变后，把我们预约好的任务拿出来依次执行 */
        this.onResolvedCallbacks.forEach(fn => fn())
      }
      
    }
    const reject = (reason) => {
      // 状态修改为失败
      if (this.state === 'pending') {
        this.state = 'rejected'
        this.reason = reason
        this.onRejectedCallbacks.forEach(fn => fn())
      }
    }
    executor(resolve, reject)
  }
  // 实现 then 方法
  then(onFulfilled, onRejected) {
    return new MPromise((resolve, reject) => {
      if (this.state === 'fulfilled') {
        // 接收成功传来的数据
        resolve(onFulfilled(this.value))
      }
      if (this.state === 'rejected') {
        // 接收失败传来的数据
        reject(onRejected(this.reason))
      }
      if(this.state === 'pending') {
        /* 因为异步导致 state 还在 pending 状态 
        所以把 要做的任务先放到预约的数组队列里
        */
        this.onResolvedCallbacks.push(() => {
          resolve(onFulfilled(this.value))
        })
        this.onRejectedCallbacks.push(() => {
          reject(onRejected(this.reason))
        })
      }
    })
  }
}
```

#### 2.2 添加静态方法
```js
class MPromise {
 constructor(executor) {
    //成功的参数
    this.value = undefined
    //失败的参数
    this.reason = undefined
    // 定义promise的状态
    this.state = 'pending'
    // 定义数组，存放稍后要完成的任务
    this.onResolvedCallbacks = []
    this.onRejectedCallbacks = []

    const resolve = (value) => {
      if (this.state === 'pending') {
        // 状态修改为成功
        this.state = 'fulfilled'
        this.value = value
        /* 成功了，在这个例子中，相当于过了 1秒了开始执行resolve了，
        状态改变后，把我们预约好的任务拿出来依次执行 */
        this.onResolvedCallbacks.forEach(fn => fn())
      }
      
    }
    const reject = (reason) => {
      // 状态修改为失败
      if (this.state === 'pending') {
        this.state = 'rejected'
        this.reason = reason
        this.onRejectedCallbacks.forEach(fn => fn())
      }
    }
    executor(resolve, reject)
  }
  // 实现 then 方法
  then(onFulfilled, onRejected) {
    return new MPromise((resolve, reject) => {
      if (this.state === 'fulfilled') {
        // 接收成功传来的数据
        resolve(onFulfilled(this.value))
      }
      if (this.state === 'rejected') {
          // 接收失败传来的数据
          try {
              if (!onRejected) {
                  reject(onFulfilled(this.reason))
              } else {
                  reject(onRejected(this.reason))
              }
          } catch (err) {
              console.log(err)
          }
      }
      if(this.state === 'pending') {
        /* 因为异步导致 state 还在 pending 状态 
        所以把 要做的任务先放到预约的数组队列里
        */
        this.onResolvedCallbacks.push(() => {
          resolve(onFulfilled(this.value))
        })
        this.onRejectedCallbacks.push(() => {
          reject(onRejected(this.reason))
        })
      }
    })
  }
  static resolve(value) {
    return new MPromise(resolve => resolve(value))
  }
  static reject(reason) {
    return new MPromise((resolve, reject) => reject(reason))
  }
  static all(promises) {
    return new MPromise((resolve, reject) => {
      // 存储promise的结果
      const results = []
      let count = 0
      promises.forEach((promise, index) => {
        // 获取到每个promise然后执行
        promise.then(value => {
          results[index] = value
          count++
          if (count === promises.length) {
            resolve(results)
          }
        })
      })
    })
  }
}
```

