# Symbol Set和Map数据结构
## Symbol 
> 概念以及引入原因
是什么？ES6 引入了的一种新的原始数据类型Symbol，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，前六种是：undefined、null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。
```js
let s = Symbol();
typeof s  // symbol
```


> 作用？保证每个对象属性的名字都是独一无二的

（怎么解决？抛出问题）
```js
let a = {a:1}
let b = {b:1}
let c = {}
c[a] = 3
c[b] = 4
console.log(c); // [object Object]: 4

```

> 接收字符串作为参数
Symbol函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。
```js
let s1 = Symbol('foo');
let s2 = Symbol('bar');
s1 // Symbol(foo)
s2 // Symbol(bar)


```

注意1： Symbol 的参数是一个对象，就会调用该对象的toString方法，将其转为字符串，然后才生成一个 Symbol 值。
注意2：Symbol函数的参数只是表示对当前 Symbol 值的描述，因此相同参数的Symbol函数的返回值是不相等的。
```js
// 没有参数的情况let s1 = Symbol();let s2 = Symbol();
s1 === s2 // false
// 有参数的情况
let s1 = Symbol('foo');let s2 = Symbol('foo');
s1 === s2 // false

```
上述引入原因的解决办法
```js
let obj = {a:2,b:3}
let obj1 = {a:3,b:4}
let s = Symbol(obj);
let s1 = Symbol(obj1);
let o = {}
o[s] = 1;
o[s1] = 2;
console.log(o);
```
> Symbol 值不能与其他类型的值进行运算，会报错。
```js
let sym = Symbol('My symbol');
"your symbol is " + sym
// TypeError: can't convert symbol to string`your symbol is ${sym}`
// TypeError: can't convert symbol to string
```
> Symbol 值可以显式转为字符串。
```js
let sym = Symbol('My symbol');
String(sym) // 'Symbol(My symbol)'
sym.toString() // 'Symbol(My symbol)'
```
> Symbol 值也可以转为布尔值，但是不能转为数值。
```js
let sym = Symbol();
Boolean(sym) // true
!sym  // false
Number(sym) // TypeErrorsym + 2 // TypeError
```
> Symbol.iterator属性
对象的Symbol.iterator属性，指向该对象的默认遍历器方法。
对象进行for...of循环时，会调用Symbol.iterator方法，返回该对象的默认遍历器。	
> Object.getOwnPropertySymbols方法
Object.getOwnPropertySymbols方法，可以获取指定对象的所有 Symbol 属性名。
Object.getOwnPropertySymbols方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。
```js
const obj = {};
let a = Symbol('a');
let b = Symbol('b');
obj[a] = 'Hello';
obj[b] = 'World';
const objectSymbols = Object.getOwnPropertySymbols(obj);
objectSymbols
// [Symbol(a), Symbol(b)]
```
> 实际应用
```js
// 常量枚举 js没有枚举类型的
    const CODE_ONE = 1;
    const CODE_TWO = 2;
    // 产生一个问题 1 2 不能重复  重复的话判断就会出错
    // symbol 哪怕你写重复了也没问题
   // 私有属性
   let private = Symbol('private')
   var obj = {
    _name:'张三',
    [private]:'私有的属性',
    say:function(){
        console.log(this[private])
    }
   }

   console.log(Object.keys(obj))
```

# Set
## Set 是什么？
> Set是新的引用型的数据结构 它类似于数组，但是成员的值都是唯一的，没有重复的值。
Set本身是一个构造函数，用来生成 Set 数据结构。
Set函数可以接受一个数组作为参数，用来初始化。

> 回顾之前的数据结构  
一般类型 Number  String  Boolean Undefined  Null  
以及前面新学习的 Symbol
引用类型  Object
> 基本用法
```js
const set = new Set([1, 2, 3, 4, 4]);
console.log(set); // Set(4) {1, 2, 3, 4}
```
> 证明Set是新的引用类型的数据结构
先想一想 以前怎么判断是数组还是对象的？
```js

let arr = [1,2,3]
let obj = {name:2}
let res = arr instanceof  Array 
let resOb = obj instanceof  Object
console.log(res); // true
console.log(resOb); //true

let resArr =  Object.prototype.toString.call(arr)
let resObj =  Object.prototype.toString.call(obj)
console.log(resArr); // [object Array]
console.log(resObj); // [object Object]

// 可以类比着来判断Set数据类型
let set = new Set([1,2,3,4])
let res = set instanceof Set
let resSet = Object.prototype.toString.call(set)
console.log(res); // true
console.log(resSet); // [object Set]
```

> 转化成数组（通过... 或者 Array.from()）
（不知道为什么没关系先记住  后面讲到了 iterator 遍历器 for...of 循环就知道了 其实就是因为我们的Set数据结构支持for of循环（内部部署了iterator接口））
```js
const set = new Set([1, 2, 3, 4, 4]);
Array.from()
[...set]
```

我们的数组去重可以怎么做？（可以通过上述来实现）
> Set数据内部判断值的机制
Set 内部判断两个值是否不同，使用的算法它类似于精确相等运算符（===） 

```js
let set = new Set();
        let a = 5;
        let b = '5';
        set.add(a);
        set.add(b);
        console.log(Array.from(set))

```
5和"5"是两个不同的值 
特殊情况就是NaN的情况 虽然NaN === NaN 返回false(其实NaN == NaN也会返回false)
但是在Set数据内部认为相等
看下面例子 add方法不知道没关系下面会讲到 其实就是向Set数据里面添加内容
```js
let set = new Set();
let a = NaN;
let b = NaN;
set.add(a);
set.add(b);set // Set {NaN}
```
上面代码向 Set 实例添加了两次NaN，但是只会加入一个。这表明，在 Set 内部，两个NaN是相等的。
接着举例子两个对象总是不相等的。（因为{} === {} 返回false 其实 {}=={}也是返回false）
```js
let set = new Set();
set.add({});
set.add({});

console.log(...set);// 此时有两项 {} {}
```
>set实例的属性和方法
属性size
```js
let set = new Set();
s.add(1).add(2).add(2);
// 注意2被加入了两次
s.size // 2
```

> 方法 add delete has clear 

```js
let set = new Set();
s.add(1).add(2).add(2);
// 注意2被加入了两次
s.size // 2
s.has(1) // true
s.has(2) // true
s.has(3) // false
s.delete(2); // 		
s.has(2) // false 

```

> 方法forEach()
Set 结构的实例与数组一样，也拥有forEach方法，用于对每个成员执行某种操作，没有返回值。
```js
let set = new Set([1, 4, 9]);
set.forEach((value, key) => console.log(key + ' : ' + value))

```

> Set和展开运算符...实现数组的并集 交集 差集
走代码
```js
let arr1 = [1,2,3]
let arr2 = [4,3,2]
let a = new Set(arr1);
let b = new Set(arr2);
// 并集let union = new Set([...a, ...b]);
// Set {1, 2, 3, 4}
// 交集
// let intersect = new Set([...a].filter(x => b.has(x)));
// set {2, 3}
// 差集let difference = new Set([...a].filter(x => !b.has(x)));
// Set {1}
```
# Map
> Map是什么？
ES6 提供的另一种新的引用类型的数据结构 它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键）
以前引用类型中的对象也是键值对的集合 但是键限于字符串
总结起来就是
Object 结构提供了“字符串—值”的对应，
Map 结构提供了“值—值”的对应，是一种更完善的 “键值对” 结构实现。
如果你需要“键值对”的数据结构，Map 比 Object 更合适

> 怎么声明Map数据结构
```js
const m = new Map();
const o = {p: 'Hello World'};
m.set(o, 'content')
m.get(o) // "content"
m.has(o) // true
m.delete(o) // true
m.has(o) // false
```
> 证明是引用类型数据
```js
let map = new Map()
let res = map instanceof Map
let resMap = Object.prototype.toString.call(map)
console.log(res); // true
console.log(resMap); // [object Map]
```

> 和之前的对象进行比较
之前用对象作为键的时候
 
```js

let o1 = {a:1} 
let o2 = {b:1}
let o3 = {}
o3[o1] = 1
o3[o2] = 2
       console.log(o3) // [object Object]: 2
         Object.keys(o3).map((v,i)=>{
            console.log(v); // [object Object]
            console.log(i); // 0
            console.log(typeof v); // string
        })
```
上面说明是会被覆盖的 此时用Map实现

```js
let o1 = {a:1} 
let o2 = {b:1}
let o3 = new Map()
o3.set(o1,'123')
o3.set(o2,'234')
console.log(o3);
console.log(o3.get(o1));
console.log(o3.get(o2));
```
> 接受数组作为参数
作为构造函数，Map 也可以接受一个数组作为参数。注意该数组的成员是一个个表示键值对的数组。

```js
const map = new Map([
  ['name', '张三'],
  ['title', 'Author']
]);
map.get('name') // "张三"
map.get('title') // "Author"
let m = new Map([
        [123,'abc'],
        ['a',{x:1,y:2}],
        [3>1,666]
    ]);

    console.log(m.get(true)); // 666

```


> 传址特点--对象作为键名，传输的是地址，所以下例中的两个{x:1}虽然长相一样，但实际值不同（存储在堆内存的两个位置）
```js
let m = new Map([
    [123,'abc'],
    [{x:1},'cdf'],]);
console.log(m.get({x:1}));-->undefined
// 可以修改成下面形式
let obj = {x:1};
let m = new Map([
    [123,'abc'],
    [obj,'cdf'],]);
console.log(m.get(obj));-->cdf

```
> Map构造函数接受数组作为参数的本质 内部机制
下面代码牵扯到数组解构的模式匹配 就是forEach的时候可以问问同学们是否懂？
```js
const items = [
  ['name', '张三'],
  ['title', 'Author']
];
const map = new Map();
items.forEach(
  ([key, value]) => map.set(k

```

> Map自带的一些方法 keys() values() entries()

```js
//2.创建一个Map(可以区分两个对象obj_2,obj_1)
const map =new Map([
    ['name','张三'],
    ['age',18],
    ['sex','男'],
    [obj_1,'天空'],
    [obj_2,'大海']
]);
console.log(map);
console.log(map.size);
map.set('pet',['哈士奇','阿拉斯加']);
console.log(map);
console.log(map.get('pet'));
console.log(map.get(obj_2));
console.log(map.delete(obj_2));
console.log(map.keys());
console.log(map.values());
// 对键值对的遍历
console.log(map.entries());
let res = map.entries()
for(i of res){
    console.log(i)
}
//3.遍历
map.forEach(function(value,index){
    console.log(index+':'+value);
})

```

> map参数的扩展
任何具有 Iterator 接口、且每个成员都是一个双元素的数组的数据结构 都可以当作Map构造函数的参数
走代码
```js
const set = new Set([
  ['foo', 1],
  ['bar', 2]
]);
const m1 = new Map(set);
m1.get('foo') // 1
const m2 = new Map([['baz', 3]]);
const m3 = new Map(m2);
m3.get('baz') // 3

```
