### 组合式API

#### computed()

接受一个 getter 函数，返回一个只读的响应式 ref 对象，也可以接受一个带有 get 和 set 函数的对象来创建一个可写的 ref 对象。
```js
const count = ref(1)
const plusOne = computed(() => count.value + 1)

console.log(plusOne.value) // 2

plusOne.value++ // 错误
```

计算属性默认是只读的，如果需要去修改计算属性的同时处理副作用，那么就需要用到 getter 和 setter 来创建。
```js
const plusOne = computed({
  get() {
    return count.value + 1
  },
  set() {
    count.value++
    if (count.value === 5) {
      alert('做点其他的事情')
    }
  }
})
```


#### 计算属性使用场景
- 根据响应式变量衍生出其他的属性
```html
<div class="container">
  <label for="number">人民币：</label>
  <input type="number" v-model="inputNumber" />
  <p>美元：{{ dollar }} $</p>
  <p>日元：{{ yen }} ￥</p>
</div>
```
```js
const inputNumber = ref(0)
const dollar = computed(() => {
  return (inputNumber.value * 0.14).toFixed(2)
})
const yen = computed(() => {
  return (inputNumber.value * 20.56).toFixed(2)
})
```
- 根据响应式对象派生出其他的属性
```html
<div class="container">
  <div class v-for="(item, index) in reactiveData" :key="index">
  <p>数量：{{ item.num }} 个</p>
  <p>
    <label for="number">价格：</label>
    <input type="number" v-model="item.price" />
  </p>
  </div>
</div>
<p>总价：{{ total }}</p>
```
```js
const reactiveData = reactive([{num: 1, price: 2}, {num: 2, price: 3}])
const total = computed(() => {
  return reactiveData.reduce((total, cur) => {
    return total + cur.num * cur.price
  }, 0)
})
```
- 根据多个响应式数据组装成新的数据
```html
<div class="container">
  <p>
    <label for="number">firstName：</label>
    <input v-model="firstName" />
  </p>
  <p>
    <label for="number">lastName：</label>
    <input v-model="lastName" />
  </p>
  <h1>{{ fullName }}</h1>
</div>
```
```js
const firstName = ref('San')
const lastName = ref('Zhang')
const fullName = computed(() => lastName.value + ' ' + firstName.value)
```