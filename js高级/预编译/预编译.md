### 预编译
预编译是上下文创建之后, js代码执行前的一段时期, 在这个时期, 会对js代码进行预处理

全局上下文创建后，会生成**变量对象VO**，VO首先寻找变量声明，将var声明的变量作为VO对象的属性名，值为undefined。然后寻找函数声明，属性值为函数本身，如果函数名与变量名冲突，函数声明会将变量声明覆盖。

#### 全局预编译
```js
console.log(a)	
var a = 100;
function a () { }
console.log(a)
```
1. 变量名。
2. 方法名。如果有重复的变量名，贼覆盖掉。

所以上面的是： 
1. funA
2. 100；

#### 函数预编译
函数上下文创建后，会生成**变量对象AO**
- 寻找变量声明, 变量名作为AO对象的属性名, 属性值置为 undefined
- **寻找形参, 形参名作为AO对象的属性名, 属性值置为 undefined**
- **将实参的值赋予形参, 即替换 AO对象中形参的属性值**
- 寻找函数声明, 函数名作为AO对象的属性名, 属性值为函数本身
- 如果函数名与变量名冲突, 函数声明会将变量声明覆盖
```js
function a(b, c) {
  console.log(b);          	
  var b = 0
  console.log(b);		
  var b = function () {
    console.log('bbbb')
  }	
  console.log(c);		
  console.log(b);				
}
a(1)
```

### 来看一道面试题
```js
function fn (a, c) {
  console.log(a)
  var a = 123
  console.log(a)
  console.log(c)
  function a() {}
  if (false) {
      var d = 678
  }
  console.log(d)
  console.log(b)
  var b = function () {}
  console.log(b)
  function c () {}
  console.log(c)
}
fn(1, 2)
```
没有全局预编译，只有函数预编译。 
在函数预编译中，1. 查看 变量声明，并且将变量的值设置为 undefined。2. 寻找形参。值为undefined 3 实参的值赋值给形参。 4 寻找函数声明 ，函数名是属姓名，属性值是函数本身。 

所以我们会先找到： 1 变量声明： a: undefined, d: undefined  b : undefined. 
                2 形参： a 依然是undefined 但是 多了一个c： undefined 
                3 将实参值赋值给形参：   a: undefiend > undefined > 1  b: undefined c: undefined > 2 d: undefined
                4. 寻找函数声明： a : a: undefiend > undefined > 1 > funA  b: undefined > funB  c: undefined > 2 > funC d: undefined.
                所以console ：  1:  funA
                               2:  123 
                               3: funC
                               4: undefined
                               5: undefined
                               6: funB
                               c: funC

